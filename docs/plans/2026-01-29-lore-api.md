# Lore API Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Convert the MCP lore server into a deployable REST API, with MCP becoming a thin client.

**Architecture:** Elysia (Bun-native) serves REST endpoints. All business logic lives in service layer. MCP server becomes a thin wrapper that calls the API via Eden client. Public endpoints for reads, API key protection for writes.

**Tech Stack:** Bun, Elysia, Eden (type-safe client), Convex (database), Infinity (embeddings)

---

## Task 1: Add Elysia Dependencies

**Files:**
- Modify: `lore-server/package.json`

**Step 1: Add Elysia and related packages**

```bash
cd lore-server && bun add elysia @elysiajs/cors @elysiajs/swagger @elysiajs/eden
```

**Step 2: Verify installation**

Run: `cd lore-server && bun pm ls | grep elysia`
Expected: Shows elysia packages installed

**Step 3: Commit**

```bash
git add lore-server/package.json lore-server/bun.lockb
git commit -m "chore: add elysia dependencies"
```

---

## Task 2: Create Lore Schema Definitions

**Files:**
- Create: `lore-server/src/api/schemas/lore.ts`

**Step 1: Write schema file**

```typescript
import { t } from "elysia";

// Response schemas
export const LoreEntrySchema = t.Object({
  id: t.String(),
  title: t.String(),
  content: t.String(),
  category: t.String(),
  tags: t.Array(t.String()),
  parentId: t.Optional(t.String()),
  metadata: t.Record(t.String(), t.Unknown()),
  createdAt: t.String(),
  updatedAt: t.String(),
});

export const LoreSummarySchema = t.Object({
  id: t.String(),
  title: t.String(),
  category: t.String(),
  tags: t.Array(t.String()),
});

export const SearchResultSchema = t.Object({
  entry: LoreEntrySchema,
  score: t.Number(),
});

// Request schemas
export const CreateLoreSchema = t.Object({
  title: t.String({ minLength: 1 }),
  content: t.String({ minLength: 1 }),
  category: t.String({ minLength: 1 }),
  tags: t.Optional(t.Array(t.String())),
  parentId: t.Optional(t.String()),
  metadata: t.Optional(t.Record(t.String(), t.Unknown())),
});

export const UpdateLoreSchema = t.Object({
  title: t.Optional(t.String({ minLength: 1 })),
  content: t.Optional(t.String({ minLength: 1 })),
  category: t.Optional(t.String({ minLength: 1 })),
  tags: t.Optional(t.Array(t.String())),
  parentId: t.Optional(t.String()),
  metadata: t.Optional(t.Record(t.String(), t.Unknown())),
});

// Query schemas
export const SearchQuerySchema = t.Object({
  q: t.String({ minLength: 1 }),
  category: t.Optional(t.String()),
  limit: t.Optional(t.Numeric({ default: 10 })),
});

export const ListQuerySchema = t.Object({
  category: t.Optional(t.String()),
  full: t.Optional(t.BooleanString({ default: false })),
});

export const ExportQuerySchema = t.Object({
  category: t.Optional(t.String()),
  format: t.Optional(t.Union([t.Literal("markdown"), t.Literal("json")])),
});

// Error schema
export const ErrorSchema = t.Object({
  error: t.String(),
});
```

**Step 2: Verify TypeScript compiles**

Run: `cd lore-server && bun run typecheck`
Expected: No errors

**Step 3: Commit**

```bash
git add lore-server/src/api/schemas/lore.ts
git commit -m "feat(api): add elysia schema definitions"
```

---

## Task 3: Create API Key Guard

**Files:**
- Create: `lore-server/src/api/guards/api-key.ts`

**Step 1: Write guard file**

```typescript
import { Elysia } from "elysia";

const API_KEY = process.env.LORE_API_KEY;

export const apiKeyGuard = new Elysia({ name: "api-key-guard" })
  .derive({ as: "scoped" }, ({ headers }) => {
    const providedKey = headers["x-api-key"];
    const isAuthorized = API_KEY && providedKey === API_KEY;
    return { isAuthorized };
  })
  .macro({
    requireApiKey: (enabled: boolean) => ({
      beforeHandle: ({ isAuthorized, error }) => {
        if (enabled && !isAuthorized) {
          return error(401, { error: "Invalid or missing API key" });
        }
      },
    }),
  });
```

**Step 2: Verify TypeScript compiles**

Run: `cd lore-server && bun run typecheck`
Expected: No errors

**Step 3: Commit**

```bash
git add lore-server/src/api/guards/api-key.ts
git commit -m "feat(api): add api key guard for write protection"
```

---

## Task 4: Refactor db.ts into Services Layer

**Files:**
- Create: `lore-server/src/services/lore.ts`
- Create: `lore-server/src/services/index.ts`
- Modify: `lore-server/src/db.ts` (will be replaced)

**Step 1: Create services/lore.ts**

Copy and refactor the existing db.ts logic:

```typescript
import { ConvexHttpClient } from "convex/browser";
import { api } from "../../convex/_generated/api.js";
import type { Id } from "../../convex/_generated/dataModel.js";
import { embed } from "./embeddings.js";

// Types
export interface LoreEntry {
  id: string;
  title: string;
  content: string;
  category: string;
  tags: string[];
  parentId?: string;
  metadata: Record<string, unknown>;
  createdAt: string;
  updatedAt: string;
}

export interface SearchResult {
  entry: LoreEntry;
  score: number;
}

export interface CreateEntryInput {
  title: string;
  content: string;
  category: string;
  tags?: string[];
  parentId?: string;
  metadata?: Record<string, unknown>;
}

export interface UpdateEntryInput {
  title?: string;
  content?: string;
  category?: string;
  tags?: string[];
  parentId?: string;
  metadata?: Record<string, unknown>;
}

export interface Stats {
  totalEntries: number;
  categoryCounts: Record<string, number>;
  lastUpdated: string | null;
}

// Convex client singleton
function getConvexUrl(): string {
  if (process.env.CONVEX_URL) {
    return process.env.CONVEX_URL;
  }
  try {
    const fs = require("node:fs");
    const path = require("node:path");
    const envPath = path.resolve(__dirname, "../../.env.local");
    if (fs.existsSync(envPath)) {
      const content = fs.readFileSync(envPath, "utf-8");
      for (const line of content.split("\n")) {
        const [key, ...vals] = line.split("=");
        if (key?.trim() === "CONVEX_URL" && vals.length > 0) {
          return vals.join("=").trim();
        }
      }
    }
  } catch {
    // Ignore errors
  }
  throw new Error("CONVEX_URL not found in environment or .env.local");
}

let client: ConvexHttpClient | null = null;

function getClient(): ConvexHttpClient {
  if (!client) {
    client = new ConvexHttpClient(getConvexUrl());
  }
  return client;
}

// Helper to convert Convex entry to LoreEntry
function convexToEntry(entry: {
  _id: Id<"lore">;
  title: string;
  content: string;
  category: string;
  tags: string[];
  parentId?: string;
  metadata?: unknown;
  createdAt: number;
  updatedAt: number;
}): LoreEntry {
  return {
    id: entry._id,
    title: entry.title,
    content: entry.content,
    category: entry.category,
    tags: entry.tags,
    parentId: entry.parentId,
    metadata: (entry.metadata as Record<string, unknown>) ?? {},
    createdAt: new Date(entry.createdAt).toISOString(),
    updatedAt: new Date(entry.updatedAt).toISOString(),
  };
}

// Service functions
export async function connect(): Promise<void> {
  await getClient().query(api.lore.listCategories, {});
}

export async function searchLore(
  query: string,
  category?: string,
  limit = 10,
): Promise<SearchResult[]> {
  const queryVector = await embed(query);

  const results = await getClient().action(api.lore.searchLore, {
    embedding: queryVector,
    category,
    limit,
  });

  return results.map((r) => ({
    entry: convexToEntry(r.entry),
    score: r.score,
  }));
}

export async function getEntry(id: string): Promise<LoreEntry | null> {
  const entries = await getClient().query(api.lore.listLore, { limit: 10000 });

  if (id.includes(":")) {
    try {
      const entry = await getClient().query(api.lore.getLore, {
        id: id as Id<"lore">,
      });
      if (entry) return convexToEntry(entry);
    } catch {
      // Not a valid Convex ID, continue
    }
  }

  for (const entry of entries) {
    const metadata = entry.metadata as Record<string, unknown> | undefined;
    if (metadata?.oldId === id || entry.title === id) {
      return convexToEntry(entry);
    }
  }

  return null;
}

export async function listEntries(category?: string): Promise<LoreEntry[]> {
  const results = await getClient().query(api.lore.listLore, {
    category,
    limit: 10000,
  });
  return results.map(convexToEntry);
}

export async function createEntry(input: CreateEntryInput): Promise<LoreEntry> {
  const textToEmbed = `${input.title}\n\n${input.content}`;
  const embedding = await embed(textToEmbed);

  const id = await getClient().mutation(api.lore.createLore, {
    title: input.title,
    content: input.content,
    category: input.category,
    tags: input.tags?.length ? input.tags : undefined,
    parentId: input.parentId,
    metadata: input.metadata,
    embedding,
  });

  const entry = await getClient().query(api.lore.getLore, { id });
  if (!entry) throw new Error("Failed to fetch created entry");

  return convexToEntry(entry);
}

export async function updateEntry(id: string, input: UpdateEntryInput): Promise<LoreEntry | null> {
  const existing = await getEntry(id);
  if (!existing) return null;

  const entries = await getClient().query(api.lore.listLore, { limit: 10000 });
  let convexId: Id<"lore"> | null = null;

  for (const entry of entries) {
    if (entry.title === existing.title) {
      convexId = entry._id;
      break;
    }
  }

  if (!convexId) return null;

  let embedding: number[] | undefined;
  if (input.title || input.content) {
    const newTitle = input.title ?? existing.title;
    const newContent = input.content ?? existing.content;
    const textToEmbed = `${newTitle}\n\n${newContent}`;
    embedding = await embed(textToEmbed);
  }

  await getClient().mutation(api.lore.updateLore, {
    id: convexId,
    title: input.title,
    content: input.content,
    category: input.category,
    tags: input.tags,
    parentId: input.parentId,
    metadata: input.metadata,
    embedding,
  });

  const updated = await getClient().query(api.lore.getLore, { id: convexId });
  return updated ? convexToEntry(updated) : null;
}

export async function deleteEntry(id: string): Promise<boolean> {
  const existing = await getEntry(id);
  if (!existing) return false;

  const entries = await getClient().query(api.lore.listLore, { limit: 10000 });
  let convexId: Id<"lore"> | null = null;

  for (const entry of entries) {
    if (entry.title === existing.title) {
      convexId = entry._id;
      break;
    }
  }

  if (!convexId) return false;

  return await getClient().mutation(api.lore.deleteLore, { id: convexId });
}

export async function getCategories(): Promise<string[]> {
  return await getClient().query(api.lore.listCategories, {});
}

export async function getStats(): Promise<Stats> {
  const entries = await getClient().query(api.lore.listLore, { limit: 10000 });

  const categoryCounts: Record<string, number> = {};
  let lastUpdated: string | null = null;
  let latestTimestamp = 0;

  for (const entry of entries) {
    categoryCounts[entry.category] = (categoryCounts[entry.category] || 0) + 1;
    if (entry.updatedAt > latestTimestamp) {
      latestTimestamp = entry.updatedAt;
      lastUpdated = new Date(entry.updatedAt).toISOString();
    }
  }

  return {
    totalEntries: entries.length,
    categoryCounts,
    lastUpdated,
  };
}

export async function healthCheck(): Promise<{
  ok: boolean;
  entryCount?: number;
  error?: string;
}> {
  try {
    const entries = await getClient().query(api.lore.listLore, { limit: 10000 });
    return { ok: true, entryCount: entries.length };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return { ok: false, error: `Convex error: ${message}` };
  }
}

export async function exportMarkdown(category?: string): Promise<string> {
  const entries = await listEntries(category);

  const byCategory = new Map<string, LoreEntry[]>();
  for (const entry of entries) {
    if (!byCategory.has(entry.category)) {
      byCategory.set(entry.category, []);
    }
    byCategory.get(entry.category)?.push(entry);
  }

  let markdown = "# The Whisker Shogunate - Lore Export\n\n";
  markdown += `*Exported: ${new Date().toISOString()}*\n\n`;

  for (const [cat, catEntries] of byCategory) {
    markdown += `## ${cat}\n\n`;
    for (const entry of catEntries) {
      markdown += `### ${entry.title}\n\n`;
      if (entry.tags.length > 0) {
        markdown += `*Tags: ${entry.tags.join(", ")}*\n\n`;
      }
      markdown += `${entry.content}\n\n`;
      markdown += "---\n\n";
    }
  }

  return markdown;
}
```

**Step 2: Create services/index.ts barrel export**

```typescript
export * from "./lore.js";
export { embed, healthCheck as embeddingHealthCheck } from "./embeddings.js";
```

**Step 3: Move embeddings.ts to services folder**

Run: `mv lore-server/src/embeddings.ts lore-server/src/services/embeddings.ts`

**Step 4: Verify TypeScript compiles**

Run: `cd lore-server && bun run typecheck`
Expected: Errors about imports (we'll fix in next task)

**Step 5: Commit**

```bash
git add lore-server/src/services/
git commit -m "feat(services): extract lore service layer from db.ts"
```

---

## Task 5: Create Lore Routes

**Files:**
- Create: `lore-server/src/api/routes/lore.ts`

**Step 1: Write lore routes**

```typescript
import { Elysia } from "elysia";
import * as loreService from "../../services/lore.js";
import { apiKeyGuard } from "../guards/api-key.js";
import {
  CreateLoreSchema,
  ErrorSchema,
  ListQuerySchema,
  LoreEntrySchema,
  LoreSummarySchema,
  SearchQuerySchema,
  SearchResultSchema,
  UpdateLoreSchema,
} from "../schemas/lore.js";
import { t } from "elysia";

export const loreRoutes = new Elysia({ prefix: "/lore" })
  .use(apiKeyGuard)

  // GET /lore/search - Semantic search
  .get(
    "/search",
    async ({ query }) => {
      const results = await loreService.searchLore(
        query.q,
        query.category,
        query.limit ? Number(query.limit) : undefined,
      );
      return results;
    },
    {
      query: SearchQuerySchema,
      response: {
        200: t.Array(SearchResultSchema),
      },
    },
  )

  // GET /lore - List entries
  .get(
    "/",
    async ({ query }) => {
      const entries = await loreService.listEntries(query.category);

      if (query.full === "true") {
        return entries;
      }

      return entries.map((e) => ({
        id: e.id,
        title: e.title,
        category: e.category,
        tags: e.tags,
      }));
    },
    {
      query: ListQuerySchema,
      response: {
        200: t.Union([t.Array(LoreEntrySchema), t.Array(LoreSummarySchema)]),
      },
    },
  )

  // GET /lore/:id - Get single entry
  .get(
    "/:id",
    async ({ params, error }) => {
      const entry = await loreService.getEntry(params.id);
      if (!entry) {
        return error(404, { error: "Entry not found" });
      }
      return entry;
    },
    {
      params: t.Object({ id: t.String() }),
      response: {
        200: LoreEntrySchema,
        404: ErrorSchema,
      },
    },
  )

  // POST /lore - Create entry (protected)
  .post(
    "/",
    async ({ body }) => {
      const entry = await loreService.createEntry(body);
      return entry;
    },
    {
      requireApiKey: true,
      body: CreateLoreSchema,
      response: {
        200: LoreEntrySchema,
      },
    },
  )

  // PATCH /lore/:id - Update entry (protected)
  .patch(
    "/:id",
    async ({ params, body, error }) => {
      const entry = await loreService.updateEntry(params.id, body);
      if (!entry) {
        return error(404, { error: "Entry not found" });
      }
      return entry;
    },
    {
      requireApiKey: true,
      params: t.Object({ id: t.String() }),
      body: UpdateLoreSchema,
      response: {
        200: LoreEntrySchema,
        404: ErrorSchema,
      },
    },
  )

  // DELETE /lore/:id - Delete entry (protected)
  .delete(
    "/:id",
    async ({ params, error }) => {
      const deleted = await loreService.deleteEntry(params.id);
      if (!deleted) {
        return error(404, { error: "Entry not found" });
      }
      return { deleted: true };
    },
    {
      requireApiKey: true,
      params: t.Object({ id: t.String() }),
      response: {
        200: t.Object({ deleted: t.Boolean() }),
        404: ErrorSchema,
      },
    },
  );
```

**Step 2: Verify TypeScript compiles**

Run: `cd lore-server && bun run typecheck`
Expected: No errors (or minor import fixes)

**Step 3: Commit**

```bash
git add lore-server/src/api/routes/lore.ts
git commit -m "feat(api): add lore CRUD routes"
```

---

## Task 6: Create Supporting Routes

**Files:**
- Create: `lore-server/src/api/routes/categories.ts`
- Create: `lore-server/src/api/routes/stats.ts`
- Create: `lore-server/src/api/routes/export.ts`
- Create: `lore-server/src/api/routes/health.ts`

**Step 1: Write categories.ts**

```typescript
import { Elysia, t } from "elysia";
import * as loreService from "../../services/lore.js";

export const categoriesRoutes = new Elysia()
  .get(
    "/categories",
    async () => {
      return await loreService.getCategories();
    },
    {
      response: {
        200: t.Array(t.String()),
      },
    },
  );
```

**Step 2: Write stats.ts**

```typescript
import { Elysia, t } from "elysia";
import * as loreService from "../../services/lore.js";

export const statsRoutes = new Elysia()
  .get(
    "/stats",
    async () => {
      return await loreService.getStats();
    },
    {
      response: {
        200: t.Object({
          totalEntries: t.Number(),
          categoryCounts: t.Record(t.String(), t.Number()),
          lastUpdated: t.Nullable(t.String()),
        }),
      },
    },
  );
```

**Step 3: Write export.ts**

```typescript
import { Elysia, t } from "elysia";
import * as loreService from "../../services/lore.js";
import { ExportQuerySchema } from "../schemas/lore.js";

export const exportRoutes = new Elysia()
  .get(
    "/export",
    async ({ query, set }) => {
      const markdown = await loreService.exportMarkdown(query.category);

      if (query.format === "json") {
        return { markdown };
      }

      set.headers["content-type"] = "text/markdown";
      return markdown;
    },
    {
      query: ExportQuerySchema,
      response: {
        200: t.Union([t.String(), t.Object({ markdown: t.String() })]),
      },
    },
  );
```

**Step 4: Write health.ts**

```typescript
import { Elysia, t } from "elysia";
import * as loreService from "../../services/lore.js";
import { embeddingHealthCheck } from "../../services/index.js";

export const healthRoutes = new Elysia()
  .get(
    "/health",
    async ({ set }) => {
      const [dbStatus, embeddingStatus] = await Promise.all([
        loreService.healthCheck(),
        embeddingHealthCheck(),
      ]);

      const healthy = dbStatus.ok && embeddingStatus.ok;

      if (!healthy) {
        set.status = 503;
      }

      return {
        status: healthy ? "healthy" : "degraded",
        services: {
          database: dbStatus,
          embeddings: embeddingStatus,
        },
      };
    },
    {
      response: {
        200: t.Object({
          status: t.String(),
          services: t.Object({
            database: t.Object({
              ok: t.Boolean(),
              entryCount: t.Optional(t.Number()),
              error: t.Optional(t.String()),
            }),
            embeddings: t.Object({
              ok: t.Boolean(),
              latencyMs: t.Optional(t.Number()),
              error: t.Optional(t.String()),
            }),
          }),
        }),
        503: t.Object({
          status: t.String(),
          services: t.Any(),
        }),
      },
    },
  );
```

**Step 5: Verify TypeScript compiles**

Run: `cd lore-server && bun run typecheck`
Expected: No errors

**Step 6: Commit**

```bash
git add lore-server/src/api/routes/
git commit -m "feat(api): add categories, stats, export, and health routes"
```

---

## Task 7: Create Main API App

**Files:**
- Create: `lore-server/src/api/index.ts`
- Create: `lore-server/src/api-server.ts`

**Step 1: Write api/index.ts**

```typescript
import { Elysia } from "elysia";
import { cors } from "@elysiajs/cors";
import { swagger } from "@elysiajs/swagger";
import { loreRoutes } from "./routes/lore.js";
import { categoriesRoutes } from "./routes/categories.js";
import { statsRoutes } from "./routes/stats.js";
import { exportRoutes } from "./routes/export.js";
import { healthRoutes } from "./routes/health.js";

export const app = new Elysia()
  .use(cors())
  .use(swagger({
    documentation: {
      info: {
        title: "Whisker Lore API",
        version: "1.0.0",
        description: "REST API for The Whisker Shogunate lore database",
      },
    },
  }))
  .use(healthRoutes)
  .use(loreRoutes)
  .use(categoriesRoutes)
  .use(statsRoutes)
  .use(exportRoutes);

export type App = typeof app;
```

**Step 2: Write api-server.ts entry point**

```typescript
import { app } from "./api/index.js";
import { connect } from "./services/lore.js";

const PORT = Number(process.env.PORT) || 3001;

async function main() {
  // Verify database connection
  await connect();
  console.log("✓ Connected to Convex");

  app.listen(PORT);
  console.log(`✓ Lore API running at http://localhost:${PORT}`);
  console.log(`✓ Swagger docs at http://localhost:${PORT}/swagger`);
}

main().catch((error) => {
  console.error("Failed to start API:", error);
  process.exit(1);
});
```

**Step 3: Verify TypeScript compiles**

Run: `cd lore-server && bun run typecheck`
Expected: No errors

**Step 4: Commit**

```bash
git add lore-server/src/api/index.ts lore-server/src/api-server.ts
git commit -m "feat(api): add main elysia app with swagger docs"
```

---

## Task 8: Update Package Scripts

**Files:**
- Modify: `lore-server/package.json`

**Step 1: Update scripts section**

Add/update these scripts:

```json
{
  "scripts": {
    "start:api": "bun src/api-server.ts",
    "start:mcp": "bun src/index.ts",
    "dev:api": "bun --watch src/api-server.ts",
    "dev:mcp": "bun --watch src/index.ts",
    "start": "bun src/api-server.ts",
    "dev": "bun --watch src/api-server.ts",
    "test": "bun test",
    "typecheck": "tsc --noEmit",
    "lint": "biome check .",
    "lint:fix": "biome check --write .",
    "format": "biome format --write ."
  }
}
```

**Step 2: Verify scripts work**

Run: `cd lore-server && bun run start:api`
Expected: Server starts on port 3001

**Step 3: Commit**

```bash
git add lore-server/package.json
git commit -m "chore: add api and mcp start scripts"
```

---

## Task 9: Write API Tests

**Files:**
- Create: `lore-server/test/api/lore.test.ts`
- Create: `lore-server/test/api/health.test.ts`

**Step 1: Write lore.test.ts**

```typescript
import { describe, expect, it, beforeAll } from "bun:test";
import { treaty } from "@elysiajs/eden";
import { app } from "../../src/api/index.js";

const api = treaty(app);

describe("GET /lore", () => {
  it("returns array of entries", async () => {
    const { data, error } = await api.lore.get();
    expect(error).toBeNull();
    expect(Array.isArray(data)).toBe(true);
  });

  it("filters by category", async () => {
    const { data } = await api.lore.get({ query: { category: "cuisine" } });
    if (data && data.length > 0) {
      expect(data.every((e: any) => e.category === "cuisine")).toBe(true);
    }
  });

  it("returns full entries when full=true", async () => {
    const { data } = await api.lore.get({ query: { full: "true" } });
    if (data && data.length > 0) {
      expect((data[0] as any).content).toBeDefined();
    }
  });
});

describe("GET /lore/search", () => {
  it("returns search results", async () => {
    const { data, error } = await api.lore.search.get({ query: { q: "food" } });
    expect(error).toBeNull();
    expect(Array.isArray(data)).toBe(true);
  });

  it("results have score", async () => {
    const { data } = await api.lore.search.get({ query: { q: "rice" } });
    if (data && data.length > 0) {
      expect(typeof (data[0] as any).score).toBe("number");
    }
  });
});

describe("GET /lore/:id", () => {
  it("returns 404 for non-existent entry", async () => {
    const { error } = await api.lore({ id: "non-existent-id" }).get();
    expect(error?.status).toBe(404);
  });
});

describe("POST /lore (protected)", () => {
  it("rejects without API key", async () => {
    const { error } = await api.lore.post({
      title: "Test",
      content: "Test content",
      category: "test",
    });
    expect(error?.status).toBe(401);
  });
});

describe("GET /categories", () => {
  it("returns array of strings", async () => {
    const { data, error } = await api.categories.get();
    expect(error).toBeNull();
    expect(Array.isArray(data)).toBe(true);
    if (data && data.length > 0) {
      expect(typeof data[0]).toBe("string");
    }
  });
});

describe("GET /stats", () => {
  it("returns stats object", async () => {
    const { data, error } = await api.stats.get();
    expect(error).toBeNull();
    expect(typeof (data as any)?.totalEntries).toBe("number");
    expect(typeof (data as any)?.categoryCounts).toBe("object");
  });
});
```

**Step 2: Write health.test.ts**

```typescript
import { describe, expect, it } from "bun:test";
import { treaty } from "@elysiajs/eden";
import { app } from "../../src/api/index.js";

const api = treaty(app);

describe("GET /health", () => {
  it("returns health status", async () => {
    const { data, error } = await api.health.get();
    expect(error).toBeNull();
    expect((data as any)?.status).toBeDefined();
    expect((data as any)?.services?.database).toBeDefined();
    expect((data as any)?.services?.embeddings).toBeDefined();
  });
});
```

**Step 3: Run tests**

Run: `cd lore-server && bun test`
Expected: Tests pass (assuming services are running)

**Step 4: Commit**

```bash
git add lore-server/test/
git commit -m "test(api): add api endpoint tests"
```

---

## Task 10: Create Thin MCP Client

**Files:**
- Create: `lore-server/src/mcp/client.ts`
- Create: `lore-server/src/mcp/index.ts`
- Modify: `lore-server/src/index.ts`

**Step 1: Write mcp/client.ts**

```typescript
import { treaty } from "@elysiajs/eden";
import type { App } from "../api/index.js";

const API_URL = process.env.LORE_API_URL || "http://localhost:3001";
const API_KEY = process.env.LORE_API_KEY;

// Create typed client
export const api = treaty<App>(API_URL);

// Helper to add auth header for write operations
export const authHeaders = API_KEY ? { "x-api-key": API_KEY } : {};
```

**Step 2: Write mcp/index.ts**

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  type CallToolResult,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { api, authHeaders } from "./client.js";

const VERSION = "1.0.0";

const server = new Server(
  { name: "whisker-lore-server", version: VERSION },
  { capabilities: { tools: { listChanged: true } } },
);

// Tool definitions (unchanged from original)
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [
    {
      name: "search_lore",
      description: "Semantic search across all lore entries.",
      inputSchema: {
        type: "object",
        properties: {
          query: { type: "string", description: "The search query" },
          category: { type: "string", description: "Optional category filter" },
          limit: { type: "number", description: "Max results (default: 10)" },
        },
        required: ["query"],
      },
    },
    {
      name: "get_entry",
      description: "Get a single lore entry by ID.",
      inputSchema: {
        type: "object",
        properties: { id: { type: "string", description: "Entry ID" } },
        required: ["id"],
      },
    },
    {
      name: "list_entries",
      description: "List all lore entries, optionally filtered by category.",
      inputSchema: {
        type: "object",
        properties: { category: { type: "string", description: "Optional category" } },
      },
    },
    {
      name: "list_categories",
      description: "List all available categories.",
      inputSchema: { type: "object", properties: {} },
    },
    {
      name: "create_entry",
      description: "Create a new lore entry.",
      inputSchema: {
        type: "object",
        properties: {
          title: { type: "string" },
          content: { type: "string" },
          category: { type: "string" },
          tags: { type: "array", items: { type: "string" } },
          parentId: { type: "string" },
          metadata: { type: "object" },
        },
        required: ["title", "content", "category"],
      },
    },
    {
      name: "update_entry",
      description: "Update an existing lore entry.",
      inputSchema: {
        type: "object",
        properties: {
          id: { type: "string" },
          title: { type: "string" },
          content: { type: "string" },
          category: { type: "string" },
          tags: { type: "array", items: { type: "string" } },
          parentId: { type: "string" },
          metadata: { type: "object" },
        },
        required: ["id"],
      },
    },
    {
      name: "delete_entry",
      description: "Delete a lore entry.",
      inputSchema: {
        type: "object",
        properties: { id: { type: "string" } },
        required: ["id"],
      },
    },
    {
      name: "export_markdown",
      description: "Export lore entries to markdown.",
      inputSchema: {
        type: "object",
        properties: { category: { type: "string" } },
      },
    },
  ],
}));

// Tool implementations via API calls
server.setRequestHandler(CallToolRequestSchema, async (request): Promise<CallToolResult> => {
  const { name, arguments: args } = request.params;
  const params = args ?? {};

  try {
    switch (name) {
      case "search_lore": {
        const { query, category, limit } = params as { query: string; category?: string; limit?: number };
        const { data, error } = await api.lore.search.get({
          query: { q: query, category, limit },
        });
        if (error) throw new Error(JSON.stringify(error));
        return { content: [{ type: "text", text: JSON.stringify(data, null, 2) }] };
      }

      case "get_entry": {
        const { id } = params as { id: string };
        const { data, error } = await api.lore({ id }).get();
        if (error) {
          if (error.status === 404) {
            return { content: [{ type: "text", text: `Entry not found: ${id}` }], isError: true };
          }
          throw new Error(JSON.stringify(error));
        }
        return { content: [{ type: "text", text: JSON.stringify(data, null, 2) }] };
      }

      case "list_entries": {
        const { category } = params as { category?: string };
        const { data, error } = await api.lore.get({ query: { category } });
        if (error) throw new Error(JSON.stringify(error));
        return { content: [{ type: "text", text: JSON.stringify(data, null, 2) }] };
      }

      case "list_categories": {
        const { data, error } = await api.categories.get();
        if (error) throw new Error(JSON.stringify(error));
        return { content: [{ type: "text", text: JSON.stringify(data, null, 2) }] };
      }

      case "create_entry": {
        const { data, error } = await api.lore.post(params as any, {
          headers: authHeaders,
        });
        if (error) throw new Error(JSON.stringify(error));
        return { content: [{ type: "text", text: `Created: ${JSON.stringify(data, null, 2)}` }] };
      }

      case "update_entry": {
        const { id, ...updates } = params as { id: string; [key: string]: any };
        const { data, error } = await api.lore({ id }).patch(updates, {
          headers: authHeaders,
        });
        if (error) {
          if (error.status === 404) {
            return { content: [{ type: "text", text: `Entry not found: ${id}` }], isError: true };
          }
          throw new Error(JSON.stringify(error));
        }
        return { content: [{ type: "text", text: `Updated: ${JSON.stringify(data, null, 2)}` }] };
      }

      case "delete_entry": {
        const { id } = params as { id: string };
        const { data, error } = await api.lore({ id }).delete(undefined, {
          headers: authHeaders,
        });
        if (error) {
          if (error.status === 404) {
            return { content: [{ type: "text", text: `Entry not found: ${id}` }], isError: true };
          }
          throw new Error(JSON.stringify(error));
        }
        return { content: [{ type: "text", text: `Deleted: ${id}` }] };
      }

      case "export_markdown": {
        const { category } = params as { category?: string };
        const { data, error } = await api.export.get({
          query: { category, format: "json" },
        });
        if (error) throw new Error(JSON.stringify(error));
        return { content: [{ type: "text", text: (data as any).markdown }] };
      }

      default:
        return { content: [{ type: "text", text: `Unknown tool: ${name}` }], isError: true };
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return { content: [{ type: "text", text: `Error: ${message}` }], isError: true };
  }
});

export async function startMcpServer() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error(`MCP server v${VERSION} connected via stdio`);
}
```

**Step 3: Update src/index.ts to use new MCP server**

```typescript
import { startMcpServer } from "./mcp/index.js";

startMcpServer().catch((error) => {
  console.error("Failed to start MCP server:", error);
  process.exit(1);
});
```

**Step 4: Verify TypeScript compiles**

Run: `cd lore-server && bun run typecheck`
Expected: No errors

**Step 5: Commit**

```bash
git add lore-server/src/mcp/ lore-server/src/index.ts
git commit -m "feat(mcp): convert to thin api client"
```

---

## Task 11: Clean Up Old Files

**Files:**
- Delete: `lore-server/src/db.ts`
- Delete: `lore-server/src/types.ts` (if exists and no longer needed)
- Update: imports in any remaining files

**Step 1: Remove old db.ts**

Run: `rm lore-server/src/db.ts`

**Step 2: Check for broken imports**

Run: `cd lore-server && bun run typecheck`
Fix any import errors by updating to use `services/lore.js`

**Step 3: Commit**

```bash
git add -A lore-server/src/
git commit -m "chore: remove old db.ts, clean up imports"
```

---

## Task 12: Update MCP Config

**Files:**
- Modify: `.mcp.json`

**Step 1: Update MCP server config**

```json
{
  "mcpServers": {
    "whisker-lore": {
      "command": "bun",
      "args": ["run", "start:mcp"],
      "cwd": "/Users/alex/REPOS/alexcatdad/the-whisker-shogunate/lore-server",
      "env": {
        "LORE_API_URL": "http://localhost:3001",
        "LORE_API_KEY": "${LORE_API_KEY}"
      }
    }
  }
}
```

**Step 2: Commit**

```bash
git add .mcp.json
git commit -m "chore: update mcp config for new api-based server"
```

---

## Task 13: Integration Test

**Step 1: Start the API**

Run: `cd lore-server && LORE_API_KEY=test-secret bun run start:api`
Expected: API starts on port 3001

**Step 2: Test endpoints manually**

```bash
# Health
curl http://localhost:3001/health

# List
curl http://localhost:3001/lore

# Search
curl "http://localhost:3001/lore/search?q=food"

# Categories
curl http://localhost:3001/categories

# Stats
curl http://localhost:3001/stats

# Swagger docs
open http://localhost:3001/swagger
```

**Step 3: Test MCP server**

Start API in one terminal, then:
```bash
cd lore-server && LORE_API_URL=http://localhost:3001 LORE_API_KEY=test-secret bun run start:mcp
```

**Step 4: Run full test suite**

Run: `cd lore-server && bun test`
Expected: All tests pass

**Step 5: Final commit**

```bash
git add -A
git commit -m "feat: complete lore api migration"
```

---

## Summary

After completing all tasks:
- **API server** at `src/api-server.ts` — Elysia REST API with Swagger docs
- **MCP server** at `src/index.ts` — Thin client calling API via Eden
- **Services** at `src/services/` — All business logic
- **Tests** at `test/api/` — Type-safe API tests
- **Scripts**: `bun run start:api`, `bun run start:mcp`
